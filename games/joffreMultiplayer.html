<!DOCTYPE html>
<html lang="fr-CA">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <link rel="icon" href="../schooltoolicon.png" type="image/x-icon">
  <title>Joffre - Multijoueur</title>
  <style>
    h1 {
      font-size: 2rem;
    }
    #menu-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      background-color: #2c3e50;
      color: white;
      border: none;
      padding: 12px 18px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 1001;
      transition: background-color 0.3s;
    }

    #menu-btn:hover {
      background-color: #1f2e3a;
    }

    #menu {
      position: fixed;
      top: 0;
      left: -260px;
      width: 260px;
      height: 100%;
      background-color: #2c3e50;
      color: white;
      padding-top: 70px;
      transition: left 0.3s ease;
      z-index: 1000;
      box-shadow: 4px 0 15px rgba(0, 0, 0, 0.2);
    }

    #menu.open {
      left: 0;
    }

    #menu a {
      display: flex;
      align-items: center;
      padding: 14px 24px;
      color: white;
      text-decoration: none;
      font-size: 1rem;
      font-weight: 500;
      transition: background-color 0.2s;
    }

    #menu a i {
      margin-right: 12px;
      width: 20px;
    }

    #menu a:hover {
      background-color: #34495e;
    }

    @media (max-width: 768px) {
        h1 {
            font-size: 28px;
        }
    }
    .card {
      width: 70px;
      margin: 8px;
      cursor: pointer;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.18), 0 1.5px 4px rgba(0,0,0,0.08);
      background: rgba(255,255,255,0.18);
      transition: transform 0.18s, box-shadow 0.18s;
      border: 2px solid rgba(255,255,255,0.18);
    }

    .card:hover {
      transform: scale(1.12) translateY(-6px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.25);
      z-index: 2;
    }

    .card.special-red {
      box-shadow: 0 0 18px 6px #ff1744, 0 4px 16px rgba(0,0,0,0.18);
    }

    .card.special-brown {
      box-shadow: 0 0 18px 6px #a0522d, 0 4px 16px rgba(0,0,0,0.18);
    }

    .card.teamate-card {
      box-shadow: 0 0 18px 6px #222, 0 4px 16px rgba(0,0,0,0.18);
    }

    .card.winner {
      border: 3px solid #ffd700;
      box-shadow: 0 0 24px 8px #ffd700, 0 4px 16px rgba(0,0,0,0.18);
    }

    .player.hand {
      transform-origin: center;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Segoe UI', 'Arial', sans-serif;
      background: linear-gradient(135deg, #232526 0%, #414345 100%);
      color: #f8f8f8;
      min-height: 100vh;
      overflow-x: hidden;
    }

    #game-content, #scoreDisplay, #log, #bid-interface {
      background: rgba(255,255,255,0.10);
      box-shadow: 0 8px 32px 0 rgba(31,38,135,0.37);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.18);
    }

    #scoreDisplay {
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #ffd700;
      font-size: 1.5rem;
      letter-spacing: 1px;
      padding: 18px 50px 12px 50px;
      border-radius: 0 0 22px 22px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.25);
      z-index: 2000;
      text-align: center;
      min-width: 340px;
    }

    #table {
      display: grid;
      grid-template-areas:
        "top top top"
        "left center right"
        "bottom bottom bottom";
      grid-template-columns: 1fr 2fr 1fr;
      grid-template-rows: 120px 220px 160px;
      gap: 10px;
      background: rgba(255,255,255,0.07);
      border-radius: 24px;
      box-shadow: 0 8px 32px 0 rgba(31,38,135,0.18);
      padding: 18px;
      margin: 70px auto 0 auto;
      max-width: 1200px;
      height: 100%;
      position: relative;
    }

    .player.hand {
      margin: 0;
      padding: 8px 0;
      background: rgba(255,255,255,0.06);
      border-radius: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 80px;
      width: 100%;
      box-sizing: border-box;
      height: fit-content;
    }

    #player-bottom, #player-top {
      flex-direction: row;
      flex-wrap: wrap;
    }

    #player-bottom {
      margin-top: 130px;
    }

    #player-left {
      flex-direction: column;
      align-items: flex-start;
      min-width: 80px;
      min-height: 350px;
      max-height: 350px;
      justify-content: center;
    }
    #player-left .card {
      transform: rotate(-90deg);
      margin-bottom: -30px;
    }

    #player-right {
      flex-direction: column;
      align-items: flex-end;
      min-width: 80px;
      min-height: 350px;
      max-height: 350px;
      justify-content: center;
    }
    #player-right .card {
      transform: rotate(90deg);
      margin-bottom: -30px;
    }

    #center {
      justify-items: center;
      align-content: center;
    }

    #player-left .card:first-child,
    #player-right .card:first-child {
      margin-bottom: 0;
    }

    #bid-interface {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(51, 51, 51, 0.95);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(0,0,0,0.6);
      z-index: 999;
      text-align: center;
      min-width: 350px;
    }

    #bid-interface h2 {
      margin-top: 0;
      color: #f7c74f;
    }

    #bid-interface label {
      font-size: 1.1rem;
      margin-right: 10px;
    }

    #bid-interface input {
      width: 80px;
      padding: 8px;
      font-size: 1.1rem;
      border-radius: 8px;
      border: 2px solid #555;
      background: #222;
      color: white;
      text-align: center;
    }

    #bid-interface button {
      margin: 15px 10px 5px 10px;
      padding: 12px 24px;
      font-size: 1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: 0.3s;
    }

    #btnBid {
      background: #f7c74f;
      color: #222;
    }

    #btnBid:hover {
      background: #ffd85a;
    }

    #btnPass {
      background: #e74c3c;
      color: white;
    }

    #btnPass:hover {
      background: #c0392b;
    }

    #trump-interface {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(51, 51, 51, 0.95);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(0,0,0,0.6);
      z-index: 999;
      text-align: center;
      min-width: 400px;
    }

    #trump-interface h2 {
      margin-top: 0;
      color: #f7c74f;
    }

    .trump-option {
      display: inline-block;
      margin: 10px;
      padding: 15px 25px;
      font-size: 1.2rem;
      border-radius: 12px;
      cursor: pointer;
      transition: 0.3s;
      border: 3px solid transparent;
    }

    .trump-option:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    }

    .trump-rouge { background: #e74c3c; color: white; }
    .trump-bleu { background: #3498db; color: white; }
    .trump-vert { background: #2ecc71; color: white; }
    .trump-brun { background: #8b4513; color: white; }

    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #232526 0%, #414345 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    #progress-bar {
      width: 300px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 20px;
    }

    #progress-fill {
      width: 0%;
      height: 100%;
      background: #f7c74f;
      transition: width 0.3s;
    }

    #tip {
      margin-top: 20px;
      color: #aaa;
      font-style: italic;
    }

    .player-label {
      position: absolute;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: bold;
    }

    #label-bottom { bottom: 5px; left: 50%; transform: translateX(-50%); }
    #label-top { top: 5px; left: 50%; transform: translateX(-50%); }
    #label-left { left: 5px; top: 50%; transform: translateY(-50%); }
    #label-right { right: 5px; top: 50%; transform: translateY(-50%); }
  </style>
</head>
<body>
    <button id="menu-btn" onmouseenter="mouseEnter('bars')" onmouseleave="mouseLeave('bars')"><i class="fas fa-bars" id="bars"></i> Menu</button>

    <div id="scoreDisplay">
      <h1 id="scoreTitle">Team 1: 0 | Team 2: 0</h1>
    </div>

  <div id="loading-screen">
    <h1>Chargement du jeu de Joffre...</h1>
    <div id="progress-bar">
      <div id="progress-fill"></div>
    </div>
    <div id="tip">Astuce : Toujours prendre en brun</div>
  </div>

  <div id="game-content" style="display: none;"></div>

  <div id="table">
    <div style="grid-area: top; position: relative;">
      <div id="player-top" class="player hand"></div>
      <div id="label-top" class="player-label">Joueur</div>
    </div>
    <div style="grid-area: right; position: relative;">
      <div id="player-right" class="player hand"></div>
      <div id="label-right" class="player-label">Joueur</div>
    </div>
    <div style="grid-area: left; position: relative;">
      <div id="player-left" class="player hand"></div>
      <div id="label-left" class="player-label">Joueur</div>
    </div>
    <div style="grid-area: bottom; position: relative;">
      <div id="player-bottom" class="player hand"></div>
      <div id="label-bottom" class="player-label">Vous</div>
    </div>
    <div id="center" style="grid-area: center;">
      <div id="center-play"></div>
    </div>
  </div>
  <div id="log"></div>

  <div id="bid-interface">
    <h2>Souhaitez-vous prendre ?</h2>
    <p id="bid-status">EnchÃ¨re actuelle : Aucune</p>
    <label>Points : </label>
    <input id="bidInput" type="number" min="7" max="12" value="7" />
    <div>
      <button id="btnBid">Prendre</button>
      <button id="btnPass">Passer</button>
    </div>
  </div>

  <script src="/auth.js"></script>
  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
  <script src="/menu.js"></script>
  <script>
    loadMenu();
  </script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDVlj8ZM8tipP_CEZZsspt5gnPupMQCIKU",
      authDomain: "joffre-17fad.firebaseapp.com",
      databaseURL: "https://joffre-17fad-default-rtdb.firebaseio.com",
      projectId: "joffre-17fad",
      storageBucket: "joffre-17fad.firebasestorage.app",
      messagingSenderId: "379635357873",
      appId: "1:379635357873:web:a16437780f312ea56eaa90",
      measurementId: "G-W0HPGLN9E1"
    };
    firebase.initializeApp(firebaseConfig);
  </script>
  <script>
    document.getElementById("menu-btn").addEventListener("click", function () {
      document.getElementById("menu").classList.toggle("open");
    });

    function mouseEnter(id) {
      document.getElementById(id).classList.add('fa-bounce');
    }
    
    function mouseLeave(id) {
      document.getElementById(id).classList.remove('fa-bounce');
    }

    const imagePaths = [
      "0_Rouge.png", "1_Rouge.png", "2_Rouge.png", "3_Rouge.png", "4_Rouge.png", "5_Rouge.png", "6_Rouge.png", "7_Rouge.png",
      "0_Vert.png", "1_Vert.png", "2_Vert.png", "3_Vert.png", "4_Vert.png", "5_Vert.png", "6_Vert.png", "7_Vert.png",
      "0_Bleu.png", "1_Bleu.png", "2_Bleu.png", "3_Bleu.png", "4_Bleu.png", "5_Bleu.png", "6_Bleu.png", "7_Bleu.png",
      "0_Brun.png", "1_Brun.png", "2_Brun.png", "3_Brun.png", "4_Brun.png", "5_Brun.png", "6_Brun.png", "7_Brun.png"
    ];

    const tips = [
      "Astuce: Le but est de gagner le bonhomme brun",
      "Astuce: Le but est de perdre le bonhomme rouge",
      "Astuce: ne jamais gagner"
    ];

    document.getElementById("tip").innerText = tips[Math.floor(Math.random() * tips.length)];

    let loadedCount = 0;
    const totalImages = imagePaths.length;

    const updateProgress = () => {
      loadedCount++;
      const percent = Math.floor((loadedCount / totalImages) * 100);
      document.getElementById("progress-fill").style.width = percent + "%";
      if (loadedCount === totalImages) {
        document.getElementById("loading-screen").style.display = "none";
        document.getElementById("game-content").style.display = "block";
      }
    };

    imagePaths.forEach(src => {
      const img = new Image();
      img.onload = updateProgress;
      img.onerror = updateProgress;
      img.src = src;
    });

    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const myPlayerNumber = parseInt(urlParams.get('playerNumber')) - 1; // Convert to 0-based
    const lobbyId = urlParams.get('lobbyId');
    const userId = urlParams.get('userId');
    const username = urlParams.get('username');
    const isHost = urlParams.get('isHost') === 'true';
    const isBot = urlParams.get('isBot') === 'true';
    
    // Get botPlayers from URL (only host sends this)
    let botPlayersFromURL = null;
    if (urlParams.get('botPlayers')) {
      try {
        botPlayersFromURL = JSON.parse(urlParams.get('botPlayers'));
        console.log("Received botPlayers from URL:", botPlayersFromURL);
      } catch (e) {
        console.error("Failed to parse botPlayers:", e);
      }
    }

    // Game state
    let gameStateRef;
    let playersRef;
    let lobbyRef;
    let myPlayerId;
    let playerNames = {};
    let isMyTurn = false;
    let lobbyJoined = false; // Track if we've successfully joined
    let originalTeamOneScore;
    let originalTeamTwoScore;

    // Firebase Auth
    firebase.auth().onAuthStateChanged((user) => {
      if (user) {
        myPlayerId = user.uid;
        gameStateRef = firebase.database().ref(`lobbies/${lobbyId}/gameState`);
        playersRef = firebase.database().ref(`lobbies/${lobbyId}/players`);
        lobbyRef = firebase.database().ref(`lobbies/${lobbyId}`);

        console.log("Loading players from:", `lobbies/${lobbyId}/players`);

        // If host, set up disconnect handler to delete lobby
        if (isHost) {
          lobbyRef.onDisconnect().remove();
        }

        // Wait a bit before starting lobby deletion listener
        setTimeout(() => {
          lobbyJoined = true;
          listenForLobbyDeletion();
        }, 2000);

        // Initialize game if host
        if (isHost) {
          console.log("I am the host, initializing game...");
          setTimeout(() => {
            initializeGame();
          }, 500);
        }

        // Listen to game state
        gameStateRef.on('value', handleGameStateUpdate);
      }
    });

    firebase.auth().signInAnonymously();

    function listenForLobbyDeletion() {
      lobbyRef.on('value', (snapshot) => {
        // Only react if we've successfully joined and lobby no longer exists
        if (lobbyJoined && !snapshot.exists()) {
          console.log("Lobby deleted, redirecting to lobby screen");
          lobbyRef.off(); // Stop listening
          alert("L'hÃ´te a quittÃ© la partie. Vous allez Ãªtre redirigÃ©.");
          window.location.href = 'joffreLobby.html';
        } else if (snapshot.exists()) {
          // Lobby exists, everything is fine
          lobbyJoined = true;
        }
      });
    }

    function initializeGame() {
      const suits = ['Bleu', 'Brun', 'Rouge', 'Vert'];
      const values = [0, 1, 2, 3, 4, 5, 6, 7];
      let deck = [];
      
      for (let suit of suits) {
        for (let val of values) {
          deck.push(`${val}_${suit}`);
        }
      }
      
      // Shuffle deck
      deck.sort(() => Math.random() - 0.5);
      
      // Deal cards
      const hands = {0: [], 1: [], 2: [], 3: []};
      for (let i = 0; i < deck.length; i++) {
        hands[i % 4].push(deck[i]);
      }

      // Use botPlayers from URL if provided, otherwise read from lobby
      if (botPlayersFromURL) {
        console.log("Using botPlayers from URL:", botPlayersFromURL);
        initializeWithBotPlayers(hands, botPlayersFromURL);
      } else {
        console.log("No botPlayers in URL, reading from lobby");
        // Fallback: Read the lobby players to determine who is a bot
        playersRef.once('value').then(snapshot => {
          const players = snapshot.val() || {};
          console.log("Host initializing - players from lobby:", players);
          
          // Mark all positions as bots by default
          const botPlayers = {0: true, 1: true, 2: true, 3: true};
          
          // Mark real players as NOT bots
          Object.values(players).forEach(player => {
            const playerNum = player.playerNumber - 1; // Convert 1-4 to 0-3
            botPlayers[playerNum] = false;
            console.log(`Position ${playerNum} is a REAL player: ${player.name}`);
          });

          console.log("Host set botPlayers:", botPlayers);
          initializeWithBotPlayers(hands, botPlayers);
        });
      }
    }

    function initializeWithBotPlayers(hands, botPlayers) {
      // Read player names from lobby
      playersRef.once('value').then(snapshot => {
        const players = snapshot.val() || {};
        const playerNamesForGame = {};
        
        // Map player names to their positions (0-3)
        Object.values(players).forEach(player => {
          const playerNum = player.playerNumber - 1;
          playerNamesForGame[playerNum] = player.name;
          console.log(`Storing player name: position ${playerNum} = ${player.name}`);
        });
        
        console.log("Player names for game:", playerNamesForGame);
        
        // Initialize game state
        gameStateRef.set({
          hands: hands,
          currentTurn: 0,
          playedCards: [],
          trumpColor: "",
          demandedColor: "",
          currentLeader: 0,
          teamOneScore: 0,
          teamTwoScore: 0,
          dealerIndex: Math.floor(Math.random() * 4),
          roundNumber: 0,
          biddingPhase: true,
          currentBidder: -1,
          highestBid: 0,
          highestBidder: -1,
          passedPlayers: [],
          bidsPlaced: [],
          takerTeam: -1,
          botPlayers: botPlayers,
          playerNames: playerNamesForGame,
          waitingForNextRound: false
        }).then(() => {
          console.log("Game state initialized by host with botPlayers:", botPlayers);
          
          // Start bidding after a short delay
          setTimeout(() => {
            gameStateRef.once('value').then(snap => {
              const state = snap.val();
              const firstBidder = (state.dealerIndex + 1) % 4;
              console.log("Starting bidding with first bidder:", firstBidder);
              console.log("botPlayers at start:", state.botPlayers);
              gameStateRef.update({
                currentBidder: firstBidder
              });
            });
          }, 1000);
        });
      });
    }

    function handleGameStateUpdate(snapshot) {
      const state = snapshot.val();
      if (!state) return;

      console.log("Game state updated:", state.currentBidder, "My number:", myPlayerNumber);
      console.log("Bot players:", state.botPlayers);

      // Update playerNames from gameState
      if (state.playerNames) {
        playerNames = state.playerNames;
        console.log("Updated playerNames from gameState:", playerNames);
        updatePlayerLabels();
      }

      // Update UI
      renderHands(state);
      updateCenter(state);
      updateScore(state);
      
      // Handle bidding phase
      if (state.biddingPhase) {
        // Host should always check if bidding should end
        if (isHost) {
          const bidsPlaced = state.bidsPlaced || [];
          if (bidsPlaced.length >= 4) {
            console.log("Host detected bidding should end with bidsPlaced:", bidsPlaced);
            checkBiddingEnd();
          }
        }
        
        if (state.currentBidder === myPlayerNumber) {
          console.log("My turn to bid!");
          showBiddingInterface(state);
        } else {
          hideBiddingInterface();
          
          // If it's a bot's turn to bid and I'm the host
          if (isHost && state.botPlayers && state.botPlayers[state.currentBidder] === true) {
            console.log("Bot's turn to bid, I'm host, triggering bot");
            setTimeout(() => {
              botBid();
            }, 1000);
          } else {
            console.log("Not my turn, not a bot's turn, or I'm not host");
          }
        }
      } else {
        hideBiddingInterface();
      }

      // Update log
      updateLog(state);

      // Check for round end
      if (state.waitingForNextRound && isHost) {
        setTimeout(() => {
          startNextRound();
        }, 3000);
      }

      // Check for game end
      if (state.teamOneScore >= 41) {
        log("ðŸ† L'Ã©quipe 1 gagne la partie!");
      } else if (state.teamTwoScore >= 41) {
        log("ðŸ† L'Ã©quipe 2 gagne la partie!");
      }
    }

    function showBiddingInterface(state) {
      const bidInterface = document.getElementById('bid-interface');
      const bidInput = document.getElementById('bidInput');
      const bidStatus = document.getElementById('bid-status');
      
      if (state.highestBid > 0) {
        bidStatus.textContent = `EnchÃ¨re actuelle : ${state.highestBid}`;
        bidInput.min = state.highestBid + 1;
        bidInput.value = Math.min(state.highestBid + 1, 12);
      } else {
        bidStatus.textContent = "EnchÃ¨re actuelle : Aucune";
        bidInput.min = 7;
        bidInput.value = 7;
      }

      // If dealer and everyone passed, must take
      if (state.currentBidder === state.dealerIndex && state.passedPlayers.length === 3) {
        document.getElementById('btnPass').style.display = 'none';
        bidStatus.textContent = "Vous devez prendre (tous ont passÃ©)";
      } else {
        document.getElementById('btnPass').style.display = 'inline-block';
      }

      bidInterface.style.display = 'block';
    }

    function hideBiddingInterface() {
      document.getElementById('bid-interface').style.display = 'none';
    }

    document.getElementById('btnBid').addEventListener('click', () => {
      const bidValue = parseInt(document.getElementById('bidInput').value);
      
      gameStateRef.once('value').then(snapshot => {
        const state = snapshot.val();
        
        if (bidValue < 7 || bidValue > 12) {
          alert("L'enchÃ¨re doit Ãªtre entre 7 et 12");
          return;
        }
        
        if (bidValue <= state.highestBid && state.highestBid > 0) {
          alert("Vous devez enchÃ©rir plus haut");
          return;
        }

        // Place bid
        const bidsPlaced = state.bidsPlaced || [];
        bidsPlaced.push(state.currentBidder);
        
        const nextBidder = (state.currentBidder + 1) % 4;
        
        console.log(`Player ${state.currentBidder} bid ${bidValue}. bidsPlaced now:`, bidsPlaced);
        
        gameStateRef.update({
          highestBid: bidValue,
          highestBidder: state.currentBidder,
          currentBidder: nextBidder,
          bidsPlaced: bidsPlaced,
          lastBidderPosition: state.currentBidder
        }).then(() => {
          checkBiddingEnd();
        });
      });
    });

    document.getElementById('btnPass').addEventListener('click', () => {
      gameStateRef.once('value').then(snapshot => {
        const state = snapshot.val();
        const passedPlayers = state.passedPlayers || [];
        passedPlayers.push(state.currentBidder);
        
        const bidsPlaced = state.bidsPlaced || [];
        bidsPlaced.push(state.currentBidder);
        
        const nextBidder = (state.currentBidder + 1) % 4;
        
        gameStateRef.update({
          passedPlayers: passedPlayers,
          currentBidder: nextBidder,
          bidsPlaced: bidsPlaced
        });

        checkBiddingEnd();
      });
    });

    let isCheckingBiddingEnd = false;

    function checkBiddingEnd() {
      if (!isHost) return;
      if (isCheckingBiddingEnd) {
        console.log("Already checking bidding end, skipping");
        return;
      }

      isCheckingBiddingEnd = true;

      setTimeout(() => {
        gameStateRef.once('value').then(snapshot => {
          const state = snapshot.val();
          const bidsPlaced = state.bidsPlaced || [];
          
          console.log("Checking bidding end. bidsPlaced:", bidsPlaced, "length:", bidsPlaced.length, "highestBidder:", state.highestBidder);
          
          // Case 1: All 4 players have acted - bidding is over
          if (bidsPlaced.length >= 4) {
            console.log("âœ… Bidding complete! Ending bidding phase.");
            if (state.highestBidder >= 0) {
              // Someone bid, they win
              endBidding(state.highestBidder, state.highestBid);
            } else {
              // Nobody bid, dealer must take at 7
              endBidding(state.dealerIndex, 7);
            }
            isCheckingBiddingEnd = false;
            return;
          }
          
          isCheckingBiddingEnd = false;
        });
      }, 100);
    }

    function botBid() {
      if (!isHost) return;

      gameStateRef.once('value').then(snapshot => {
        const state = snapshot.val();
        const currentBidder = state.currentBidder;
        
        // Check if it's really a bot (using numeric keys now)
        if (!state.botPlayers || state.botPlayers[currentBidder] !== true) {
          console.log(`Position ${currentBidder} is not a bot, skipping`);
          return; // Not a bot, don't do anything
        }

        console.log(`Bot at position ${currentBidder} is bidding`);

        const hand = state.hands[currentBidder] || [];
        const bidsPlaced = state.bidsPlaced || [];
        const passedPlayers = state.passedPlayers || [];
        
        // Simple bot logic: pass most of the time, bid if good hand
        const shouldBid = Math.random() < 0.3; // 30% chance to bid
        
        if (shouldBid && state.highestBid < 10) {
          // Bot decides to bid
          const bidValue = state.highestBid > 0 ? state.highestBid + 1 : 7;
          
          bidsPlaced.push(currentBidder);
          const nextBidder = (currentBidder + 1) % 4;
          
          gameStateRef.update({
            highestBid: bidValue,
            highestBidder: currentBidder,
            currentBidder: nextBidder,
            bidsPlaced: bidsPlaced,
            lastBidderPosition: currentBidder
          });
          
          log(`${playerNames[currentBidder] || 'Bot'} prend Ã  ${bidValue}!`);
        } else {
          // Bot passes
          passedPlayers.push(currentBidder);
          bidsPlaced.push(currentBidder);
          const nextBidder = (currentBidder + 1) % 4;
          
          gameStateRef.update({
            passedPlayers: passedPlayers,
            currentBidder: nextBidder,
            bidsPlaced: bidsPlaced
          });
          
          log(`${playerNames[currentBidder] || 'Bot'} passe.`);
        }
        
        checkBiddingEnd();
      });
    }

    function endBidding(winner, bid) {
      if (!isHost) return;

      const takerTeam = (winner === 0 || winner === 2) ? 1 : 2;
      
      gameStateRef.update({
        biddingPhase: false,
        highestBidder: winner,
        highestBid: bid,
        takerTeam: takerTeam,
        currentTurn: winner,
        currentLeader: winner
      }).then(() => {
        log(`${playerNames[winner] || 'Joueur ' + (winner + 1)} prend avec ${bid} points!`);
        
        // If winner is a bot, trigger bot play
        setTimeout(() => {
          gameStateRef.once('value').then(snap => {
            const state = snap.val();
            if (state.botPlayers && state.botPlayers[winner] === true) {
              botPlay();
            }
          });
        }, 1000);
      });
    }

    function getPositionForPlayer(playerNum) {
      // Calculate relative position from myPlayerNumber
      // Bottom(me) -> Right(+1) -> Top(+2) -> Left(+3)
      const relativePos = (playerNum - myPlayerNumber + 4) % 4;
      
      switch(relativePos) {
        case 0: return 'bottom';
        case 1: return 'right';
        case 2: return 'top';
        case 3: return 'left';
      }
    }

    function renderHands(state) {
      const positions = ['bottom', 'right', 'top', 'left'];
      
      positions.forEach(pos => {
        const el = document.getElementById(`player-${pos}`);
        el.innerHTML = '';
      });

      // Safety check: make sure hands exist and are complete
      if (!state.hands || typeof state.hands !== 'object') {
        console.warn("Hands not ready yet, skipping render");
        return;
      }

      // Render each player's hand in the correct position
      for (let playerNum = 0; playerNum < 4; playerNum++) {
        const position = getPositionForPlayer(playerNum);
        const el = document.getElementById(`player-${position}`);
        const hand = state.hands[playerNum];
        
        // Safety check: make sure this player's hand exists
        if (!hand || !Array.isArray(hand)) {
          console.warn(`Hand for player ${playerNum} not ready yet`);
          continue;
        }
        
        let displayHand = hand;
        
        // Sort my hand
        if (playerNum === myPlayerNumber) {
          const order = ['Bleu', 'Brun', 'Rouge', 'Vert'];
          displayHand = [...hand].sort((a, b) => {
            const colorA = getColor(a);
            const colorB = getColor(b);
            const valueA = getValue(a);
            const valueB = getValue(b);
            
            if (colorA === colorB) return valueA - valueB;
            return order.indexOf(colorA) - order.indexOf(colorB);
          });
        }

        for (let card of displayHand) {
          const img = document.createElement('img');
          
          // Show card face only for my hand
          if (playerNum === myPlayerNumber) {
            img.src = `${card}.png`;
            img.onclick = () => playCard(card);
          } else {
            img.src = `back.png`;
          }
          
          img.className = 'card';
          el.appendChild(img);
        }
      }
    }

    function playCard(card) {
      gameStateRef.once('value').then(snapshot => {
        const state = snapshot.val();
        
        // Check if it's my turn
        if (state.currentTurn !== myPlayerNumber) {
          log("Ce n'est pas votre tour!");
          return;
        }

        // Check if bidding is still active
        if (state.biddingPhase) {
          log("La phase d'enchÃ¨res est en cours");
          return;
        }

        if (state.playedCards.length >= 4) {
          log("Attendez la prochaine manche!");
          return;
        }

        const hand = state.hands[myPlayerNumber];
        if (!hand.includes(card)) return;

        // Validate card play
        const playedCards = state.playedCards || [];
        
        if (playedCards.length === 0) {
          // First card sets trump color
          const trumpColor = getColor(card);
          playCardToFirebase(card, state, trumpColor);
        } else {
          // Must follow suit if possible
          const demandedColor = state.demandedColor || getColor(playedCards[0].card);
          const cardColor = getColor(card);
          
          if (cardColor === demandedColor) {
            playCardToFirebase(card, state);
          } else if (hasColor(hand, demandedColor)) {
            log("Vous devez suivre la couleur!");
            return;
          } else {
            playCardToFirebase(card, state);
          }
        }
      });
    }

    function playCardToFirebase(card, state, trumpColor = null) {
      const newHand = state.hands[myPlayerNumber].filter(c => c !== card);
      const newPlayedCards = state.playedCards || [];
      
      newPlayedCards.push({
        player: myPlayerNumber,
        card: card
      });

      const updates = {
        [`hands/${myPlayerNumber}`]: newHand,
        playedCards: newPlayedCards,
        currentTurn: (state.currentTurn + 1) % 4
      };

      // Set trump color ONLY if this is the very first card of the round
      if (trumpColor && !state.trumpColor) {
        updates.trumpColor = trumpColor;
        updates.demandedColor = trumpColor;
        console.log(`ðŸŽ´ Trump color set to: ${trumpColor}`);
      } else if (newPlayedCards.length === 1) {
        // First card of a trick (not the round), set demanded color
        updates.demandedColor = getColor(card);
      }

      gameStateRef.update(updates);

      // Check if trick is complete
      if (newPlayedCards.length === 4) {
        setTimeout(() => {
          processTrickEnd();
        }, 1500);
      } else {
        // Bot turn
        if (isHost) {
          setTimeout(() => {
            botPlay();
          }, 800);
        }
      }
    }

    function botPlay() {
      gameStateRef.once('value').then(snapshot => {
        const state = snapshot.val();
        const currentPlayer = state.currentTurn;
        
        // Check if it's a bot using botPlayers (numeric keys)
        if (!state.botPlayers || state.botPlayers[currentPlayer] !== true) {
          return; // Wait for real player
        }

        // Bot logic
        const hand = state.hands[currentPlayer];
        if (!hand || hand.length === 0) return;

        const playedCards = state.playedCards || [];
        let cardToPlay;

        if (playedCards.length === 0) {
          // First to play
          const safe = hand.filter(c => c !== "0_Rouge" && c !== "0_Brun");
          if (safe.length > 0) {
            safe.sort((a, b) => getValue(a) - getValue(b));
            cardToPlay = safe[Math.floor(safe.length / 2)];
          } else {
            cardToPlay = hand[Math.floor(Math.random() * hand.length)];
          }
          
          // Set trump color
          const trumpColor = getColor(cardToPlay);
          playBotCard(currentPlayer, cardToPlay, state, trumpColor);
        } else {
          cardToPlay = chooseAdvancedCard(currentPlayer, hand, playedCards, state);
          playBotCard(currentPlayer, cardToPlay, state);
        }
      });
    }

    function playBotCard(playerNum, card, state, trumpColor = null) {
      const newHand = state.hands[playerNum].filter(c => c !== card);
      const newPlayedCards = state.playedCards || [];
      
      newPlayedCards.push({
        player: playerNum,
        card: card
      });

      const updates = {
        [`hands/${playerNum}`]: newHand,
        playedCards: newPlayedCards,
        currentTurn: (state.currentTurn + 1) % 4
      };

      // Set trump color ONLY if this is the very first card of the round
      if (trumpColor && !state.trumpColor) {
        updates.trumpColor = trumpColor;
        updates.demandedColor = trumpColor;
        console.log(`ðŸŽ´ Bot set trump color to: ${trumpColor}`);
      } else if (newPlayedCards.length === 1) {
        // First card of a trick (not the round), set demanded color
        updates.demandedColor = getColor(card);
      }

      gameStateRef.update(updates);

      if (newPlayedCards.length === 4) {
        setTimeout(() => {
          processTrickEnd();
        }, 1500);
      } else {
        setTimeout(() => {
          botPlay();
        }, 800);
      }
    }

    function chooseAdvancedCard(botIndex, hand, cardsPlayed, state) {
      const demandedColor = state.demandedColor || getColor(cardsPlayed[0].card);
      const hasColor = hand.filter(card => getColor(card) === demandedColor);

      // If 0_Rouge is in the trick, try to win it
      if (cardsPlayed.some(pc => pc.card === "0_Rouge")) {
        if (hasColor.length > 0) {
          return hasColor.reduce((a, b) => getValue(a) > getValue(b) ? a : b);
        } else {
          return hand.reduce((a, b) => getValue(a) > getValue(b) ? a : b);
        }
      }

      // If 0_Brun is in the trick, try to lose it
      if (cardsPlayed.some(pc => pc.card === "0_Brun")) {
        if (hasColor.length > 0) {
          return hasColor.reduce((a, b) => getValue(a) < getValue(b) ? a : b);
        } else {
          return hand.reduce((a, b) => getValue(a) < getValue(b) ? a : b);
        }
      }

      // Otherwise, play normally
      if (hasColor.length > 0) {
        const playedValues = cardsPlayed
          .filter(c => getColor(c.card) === demandedColor)
          .map(c => getValue(c.card));
        const highestPlayed = Math.max(...playedValues, -1);
        const myValues = hasColor.map(c => getValue(c));
        const canWin = myValues.some(v => v > highestPlayed);
        
        if (canWin) {
          const winningCards = hasColor.filter(c => getValue(c) > highestPlayed);
          return winningCards.reduce((a, b) => getValue(a) < getValue(b) ? a : b);
        } else {
          return hasColor.reduce((a, b) => getValue(a) < getValue(b) ? a : b);
        }
      }

      // Can't follow suit
      if (hand.includes("0_Brun")) return "0_Brun";
      if (hand.includes("0_Rouge")) return "0_Rouge";
      return hand.reduce((a, b) => getValue(a) < getValue(b) ? a : b);
    }

    function processTrickEnd() {
      gameStateRef.once('value').then(snapshot => {
        const state = snapshot.val();
        const playedCards = state.playedCards || [];
        
        if (playedCards.length !== 4) return;

        const winner = getWinner(playedCards, state.trumpColor);
        
        let team1Points = 0;
        let team2Points = 0;
        
        // Winner gets 1 point
        if (winner === 0 || winner === 2) {
          team1Points = 1;
        } else {
          team2Points = 1;
        }

        // Check for special cards
        playedCards.forEach(pc => {
          if (pc.card === '0_Rouge') {
            if (winner === 0 || winner === 2) {
              team1Points += 5;
            } else {
              team2Points += 5;
            }
          }
          if (pc.card === '0_Brun') {
            if (winner === 0 || winner === 2) {
              team1Points -= 3;
            } else {
              team2Points -= 3;
            }
          }
        });

        const newTeam1Score = state.teamOneScore + team1Points;
        const newTeam2Score = state.teamTwoScore + team2Points;

        // Check if round is over
        
        if (!state.hands) {
          console.log("Round is over! Checking if taker made their bid...");
          
          // Check if taker made their bid
          const takerTeam = state.takerTeam;
          const takerBid = state.highestBid;
          
          let finalTeam1Score = newTeam1Score;
          let finalTeam2Score = newTeam2Score;
          
          if (takerTeam === 1) {
            if (newTeam1Score < takerBid) {
              finalTeam1Score = originalTeamOneScore - takerBid;
              finalTeam2Score = newTeam2Score; // Keep their points
              log(`L'Ã©quipe 1 n'a pas fait son contrat! -${takerBid} points`);
            } else {
              log(`L'Ã©quipe 1 a rÃ©ussi son contrat!`);
            }
          } else if (takerTeam === 2) {
            if (newTeam2Score < takerBid) {
              finalTeam2Score = originalTeamTwoScore - takerBid;
              finalTeam1Score = newTeam1Score; // Keep their points
              log(`L'Ã©quipe 2 n'a pas fait son contrat! -${takerBid} points`);
            } else {
              log(`L'Ã©quipe 2 a rÃ©ussi son contrat!`);
            }
          }

          // Wait 3 seconds before clearing cards and starting next round
          setTimeout(() => {
            gameStateRef.update({
              playedCards: [],
              currentLeader: winner,
              currentTurn: winner,
              demandedColor: "",
              teamOneScore: finalTeam1Score,
              teamTwoScore: finalTeam2Score,
              waitingForNextRound: true
            }).then(() => {
              console.log("Round end state updated, waitingForNextRound = true");
            });
          }, 3000); // Show final trick for 3 seconds
        } else {
          // Not end of round, just end of trick - wait before clearing
          setTimeout(() => {
            gameStateRef.update({
              playedCards: [],
              currentLeader: winner,
              currentTurn: winner,
              demandedColor: "",
              teamOneScore: newTeam1Score,
              teamTwoScore: newTeam2Score
            }).then(() => {
              console.log("Trick cleared, continuing play");
              
              // Continue play
              setTimeout(() => {
                botPlay();
              }, 500);
            });
          }, 2000); // Show trick for 2 seconds
        }
      });
    }

    function startNextRound() {
      if (!isHost) return;

      gameStateRef.once('value').then(snapshot => {
        const state = snapshot.val();
        originalTeamOneScore = state.teamOneScore;
        originalTeamTwoScore = state.teamTwoScore;
        
        console.log("Starting next round. Current scores - Team1:", state.teamOneScore, "Team2:", state.teamTwoScore);
        
        // Check for game end
        if (state.teamOneScore >= 41) {
          log("ðŸ† L'Ã©quipe 1 gagne la partie!");
          return; // Game is over
        } else if (state.teamTwoScore >= 41) {
          log("ðŸ† L'Ã©quipe 2 gagne la partie!");
          return; // Game is over
        }

        // Shuffle and deal new cards
        const suits = ['Bleu', 'Brun', 'Rouge', 'Vert'];
        const values = [0, 1, 2, 3, 4, 5, 6, 7];
        let deck = [];
        
        for (let suit of suits) {
          for (let val of values) {
            deck.push(`${val}_${suit}`);
          }
        }
        
        deck.sort(() => Math.random() - 0.5);
        
        const hands = {0: [], 1: [], 2: [], 3: []};
        for (let i = 0; i < deck.length; i++) {
          hands[i % 4].push(deck[i]);
        }

        const newDealer = (state.dealerIndex + 1) % 4;
        const firstBidder = (newDealer + 1) % 4;

        // Preserve botPlayers and playerNames
        const botPlayers = state.botPlayers || {0: true, 1: true, 2: true, 3: true};
        const playerNamesFromState = state.playerNames || {};

        console.log("Dealing new round. New dealer:", newDealer, "First bidder:", firstBidder);

        // Use .set() to update everything atomically
        gameStateRef.set({
          hands: hands,
          currentTurn: firstBidder,
          playedCards: [],
          trumpColor: "",
          demandedColor: "",
          currentLeader: firstBidder,
          teamOneScore: state.teamOneScore,
          teamTwoScore: state.teamTwoScore,
          dealerIndex: newDealer,
          roundNumber: (state.roundNumber || 0) + 1,
          biddingPhase: true,
          currentBidder: firstBidder,
          highestBid: 0,
          highestBidder: -1,
          passedPlayers: [],
          bidsPlaced: [],
          takerTeam: -1,
          botPlayers: botPlayers,
          playerNames: playerNamesFromState,
          waitingForNextRound: false
        }).then(() => {
          console.log("New round started successfully!");
        });
      });
    }

    function getWinner(playedCards, trumpColor) {
      const leadColor = getColor(playedCards[0].card);
      let best = playedCards[0];

      for (let i = 1; i < playedCards.length; i++) {
        const current = playedCards[i];
        const currentColor = getColor(current.card);
        const bestColor = getColor(best.card);

        const currentIsTrump = currentColor === trumpColor;
        const bestIsTrump = bestColor === trumpColor;

        if (currentIsTrump && !bestIsTrump) {
          best = current;
        } else if (
          currentColor === bestColor &&
          getValue(current.card) > getValue(best.card)
        ) {
          best = current;
        } else if (!bestIsTrump && currentColor === leadColor && bestColor !== leadColor) {
          best = current;
        }
      }

      return best.player;
    }

    function hasColor(hand, color) {
      return hand.some(card => getColor(card) === color);
    }

    function getColor(cardName) {
      return cardName.split('_')[1];
    }

    function getValue(cardName) {
      return parseInt(cardName.split('_')[0]);
    }

    function updateCenter(state) {
      const div = document.getElementById('center-play');
      div.innerHTML = '';

      const playedCards = state.playedCards || [];
      const winner = playedCards.length === 4 ? getWinner(playedCards, state.trumpColor) : null;

      for (let pc of playedCards) {
        const img = document.createElement('img');
        img.src = `${pc.card}.png`;
        img.className = 'card';

        if (pc.card === '0_Rouge') {
          img.classList.add('special-red');
        } else if (pc.card === '0_Brun') {
          img.classList.add('special-brown');
        }

        // Highlight teammate's card
        const myTeam = (myPlayerNumber === 0 || myPlayerNumber === 2) ? 1 : 2;
        const cardTeam = (pc.player === 0 || pc.player === 2) ? 1 : 2;
        if (cardTeam === myTeam && pc.player !== myPlayerNumber) {
          img.classList.add('teamate-card');
        }

        if (pc.player === winner) {
          img.classList.add('winner');
        }

        div.appendChild(img);
      }
    }

    function updateScore(state) {
      const scoreTitle = document.getElementById('scoreTitle');
      scoreTitle.textContent = `Team 1: ${state.teamOneScore} | Team 2: ${state.teamTwoScore}`;
    }

    function updatePlayerLabels() {
      console.log("Updating player labels with playerNames:", playerNames);
      
      for (let i = 0; i < 4; i++) {
        const position = getPositionForPlayer(i);
        const label = document.getElementById(`label-${position}`);
        
        if (!label) {
          console.error(`Label not found for position: ${position}`);
          continue;
        }
        
        if (i === myPlayerNumber) {
          label.textContent = `Vous (${username})`;
          console.log(`Set my label (${position}): Vous (${username})`);
        } else {
          const playerName = playerNames[i];
          if (playerName) {
            label.textContent = playerName;
            console.log(`Set label (${position}) for player ${i}: ${playerName}`);
          } else {
            label.textContent = `Bot ${i + 1}`;
            console.log(`No name for player ${i}, set to: Bot ${i + 1}`);
          }
        }
      }
    }

    function updateLog(state) {
      // Update game log based on state
      if (state.biddingPhase) {
        if (state.currentBidder === myPlayerNumber) {
          log("Ã€ vous d'enchÃ©rir!");
        } else {
          const bidderName = playerNames[state.currentBidder] || `Joueur ${state.currentBidder + 1}`;
          log(`${bidderName} rÃ©flÃ©chit...`);
        }
      } else if (state.currentTurn === myPlayerNumber) {
        log("Ã€ vous de jouer!");
      } else {
        const playerName = playerNames[state.currentTurn] || `Joueur ${state.currentTurn + 1}`;
        log(`${playerName} joue...`);
      }

      if (state.trumpColor) {
        log(`Atout: ${state.trumpColor}`);
      }
    }

    function log(text) {
      const logEl = document.getElementById('log');
      logEl.textContent = text;
    }
  </script>
</body>
</html>